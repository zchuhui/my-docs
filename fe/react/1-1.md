# Diff 算法原理

以下用「搭积木」的比喻通俗解释 React diff 算法原理。


### 🌟 **核心目标**  
**用最小的代价更新真实 DOM**（就像只换掉坏掉的积木块，而不是拆了重建整个房子）

---

### 🧩 **三大策略**
#### 1️⃣ **同级比较（不跨层对比）**  
- **规则**：如果新旧节点层级不同（比如从 `<div>` 变成 `<span>`），直接销毁旧树，创建新树  
- **例子**：  
```jsx
  // 旧结构           // 新结构
  <div>              <span>
    <A />              <A />
  </div>             </span>
  ```
  React 会直接销毁 `<div>` 和 `<A>`，重新创建 `<span>` 和 `<A>`

---

#### 2️⃣ **Key 值识别（列表对比核心）**  
- **规则**：通过 `key` 识别同一层级中哪些元素可以复用  
- **无 Key 的问题**：  
  ```jsx
  // 旧列表          // 新列表（顺序调换）
  [<li>1</li>,      [<li>2</li>,
   <li>2</li>]       <li>1</li>]
  ```
  没有 `key` 时，React 会认为第一个 `<li>` 从 "1" 变成了 "2"，第二个从 "2" 变成 "1"，导致不必要的更新

- **正确使用 Key**：  
  ```jsx
  [<li key="a">1</li>,  [<li key="b">2</li>,
   <li key="b">2</li>]   <li key="a">1</li>]
  ```
  React 通过 `key` 识别出元素只是交换了位置，直接移动 DOM 节点而非重新创建

---

#### 3️⃣ **类型判断（组件/元素类型不同直接替换）**  
- **规则**：如果组件类型不同（如从 `<Button>` 变成 `<Input>`），直接销毁旧组件及其子树  
- **例子**：  
  ```jsx
  // 旧组件          // 新组件
  <Button />        <Input />
  ```
  React 会直接卸载 `<Button>`，然后挂载 `<Input>`

---

### 🛠 **Diff 过程演示**
假设新旧虚拟 DOM 树如下：
```
旧树           新树
    A               A
   / \             / \
  B   C           B   D
     /               / \
    D               E   F
```

React 的对比过程：
1. 对比 A → A（相同，保留）
2. 对比 A 的子节点：
   - B → B（相同，保留）
   - C → D（不同，删除 C 和其子树 D，创建新节点 D）
3. 处理新 D 的子节点：
   - 创建 E 和 F

**实际 DOM 操作**：删除 `<C>` 和 `<D>`，创建 `<D>`、`<E>`、`<F>`

---

### ⚡ **性能优化关键**
1. **合理使用 Key**：  
   - 列表项必须用**唯一稳定标识**（如数据库 ID）  
   - 避免用数组索引（当列表顺序变化时会导致性能问题）

2. **保持组件结构稳定**：  
   - 避免频繁改变组件类型（如条件渲染中切换不同组件类型）

3. **避免跨层级移动**：  
   - 尽量保持节点在同一层级（减少整树卸载/重建）

---

### 💡 **为什么比传统 Diff 快？**  
传统树对比算法时间复杂度 O(n³)，React 通过三大策略优化到 **O(n)**：  
1. 只同级对比 → 减少对比范围  
2. 类型不同直接跳过 → 减少深度遍历  
3. Key 值识别 → 精确复用节点  

---

就像拼乐高时，你只检查需要替换的零件，而不是拆掉整个模型——这就是 React diff 算法的智慧！ 🧠✨

